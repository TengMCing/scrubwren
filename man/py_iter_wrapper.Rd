% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/py_iter_wrapper.R
\name{py_iter_wrapper}
\alias{py_iter_wrapper}
\title{Wrap a Python iterable with a custom function}
\usage{
py_iter_wrapper(obj, func)
}
\arguments{
\item{obj}{A Python iterable or iterator object (from \code{reticulate}).}

\item{func}{An R or Python function to apply to each element of the iterable.}
}
\value{
A Python iterator object with elements transformed by \code{func}.
}
\description{
This function takes a Python iterable object and a wrapper function, and returns
a Python-style iterator where each element is transformed by the wrapper function
upon iteration. If the input object is already a Python iterator, it will be used directly.
}
\details{
\itemize{
\item If \code{obj} is iterable but not an iterator, it is first converted to a Python iterator.
\item The returned object implements the Python iterator protocol (\verb{__next__} and \verb{__len__}).
\item Each call to \code{next()} on the iterator returns \code{func(element)}.
}
}
\examples{
\dontrun{
my_list <- py_builtins$list(1:5)
wrapped_iter <- py_iter_wrapper(my_list, function(x) x^2)
reticulate::iter_next(wrapped_iter)  # Returns 1
reticulate::iter_next(wrapped_iter)  # Returns 4
}

}
