% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/py_for.R
\name{py_comprehension}
\alias{py_comprehension}
\title{Python-Style Comprehension in R}
\usage{
py_comprehension(
  loop_spec_list,
  body,
  env = parent.frame(),
  format = py_builtins$list()
)
}
\arguments{
\item{loop_spec_list}{Formula/List. A single formula or a
list of formulas specifying the loops. Each formula must have the form
\code{var ~ iterable} or \code{var ~ iterable | condition}, where \code{var} is the
loop variable and \code{iterable} is a Python iterable.
When multiple formulas are provided, each additional formula defines a
deeper loop, with the last formula representing the innermost loop.
The \code{condition} will be wrapped using \link{py_builtins}\verb{$bool()}, so it can be
either an R boolean or a Python value compatible with Pythonâ€™s
\href{https://docs.python.org/3/library/stdtypes.html#truth}{truth-testing procedure}.}

\item{body}{Expression. An R expression to evaluate inside the innermost loop.
Its result is collected into the comprehension output.}

\item{env}{Environment. The parent environment for evaluation; defaults to
the caller's environment. The comprehension is evaluated
in a \strong{new environment} created on top of this provided \code{env}, so that
variables created or modified inside \code{body} do not affect the outer
environment unless global modification is explicitly used.}

\item{format}{A Python collection type or a regular R list to store the results.
Defaults to a Python list (\link{py_builtins}\verb{$list()}).}
}
\value{
A Python collection or R list containing the results of the comprehension.
}
\description{
Evaluate Python-like comprehensions in R. Supports multiple nested loops
with optional conditions, returning results in a chosen Python collection
type (\code{list}, \code{tuple}, \code{set}, or \code{dict}) or as a regular R list.
Conceptually, it works like \code{\link[=lapply]{lapply()}} for Python objects, but
this function offers additional return types and more flexible
control over iteration.
}
\details{
\subsection{Dictionary return type}{

When \verb{format = }\link{py_builtins}\verb{$dict()}, each evaluation of \code{body} must
be a \strong{key-value pair}. Valid pair formats include:
\itemize{
\item A Python tuple of length 2
\item A Python list of length 2
\item A regular R list of length 2
}

The first element is used as the key and the second as the value.
This allows creating dictionaries in Python style directly from R
comprehensions.
}

\subsection{Side effects}{

Like \code{\link[=lapply]{lapply()}}, this function evaluates \code{body} in a local scope, so
assignments normally do not affect the caller environment. To produce side
effects, use \link{<<-}, \code{\link[=assign]{assign()}} with a suitable environment, or modify an
environment variable directly (see \code{\link[=environment]{environment()}}).
}

\subsection{Performance warnings}{

Looping over Python objects in R can be \strong{inefficient}. In each iteration,
\code{reticulate} must pass handles between R and Python, often performing
implicit or explicit object conversions and copies.
If the \code{body} of your loop is lightweight and you need to iterate over a
large Python object, consider defining a Python function via
\code{\link[reticulate:py_run]{reticulate::py_run_string()}} or \link{py_builtins}\verb{$exec()} and calling it directly.
You can also use \code{r.var} (where \code{var} is any R variable name) to access or
assign R objects directly from Python, which may help avoid unnecessary data transfer.
Native Python tools are \strong{significantly faster} in such cases!

For example, instead of doing:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{y <- py_comprehension(x ~ reticulate::r_to_py(1:100000), x^2)
}\if{html}{\out{</div>}}

it is better to do:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{function_def <- "
def list_square(n):
    return [x ** 2 for x in range(1, n + 1)]
"
my_func <- reticulate::py_run_string(function_def, local = TRUE, convert = FALSE)
y <- my_func$list_square(100000L)
}\if{html}{\out{</div>}}

Note that we need to set \code{local = TRUE}, so that the returned dictionary
is not within the main module. The main module created by \code{reticulate}
automatically converts Python objects to R objects, unless we disable this
behavior for the entire module. Doing so, however, could interfere
with \code{reticulate}'s internals. Defining the function in a private dictionary
with \code{convert = FALSE} allows us to keep objects as native Python types,
which is important when working with large integers that could otherwise
overflow when converted back to R.
}
}
\examples{
\dontrun{
# Simple Python-style comprehension
py_comprehension(
  i ~ reticulate::r_to_py(1:3),
  i^2
)

# Nested loops with conditions
test <- reticulate::r_to_py(list(list(1, 2, 3), list(1, 2), list(1)))
py_comprehension(
  c(
    x ~ test | py_builtins$len(x) > 1,
    z ~ x | z > 1
  ),
  {
    a <- z + 1
    a
  }
)

# Nested comprehension
py_comprehension(i ~ reticulate::r_to_py(1:5),
  py_comprehension(j ~ reticulate::r_to_py(1:5) | j >= i, j)
)

# Return results as a regular R list
py_comprehension(
  i ~ reticulate::r_to_py(1:3),
  i^2,
  format = list()
)

# Return results as a Python tuple
py_comprehension(
  i ~ reticulate::r_to_py(1:3),
  i^2,
  format = py_builtins$tuple()
)

# Return results as a Python set
py_comprehension(
  i ~ reticulate::r_to_py(c(1, 2, 2, 3)),
  i^2,
  format = py_builtins$set()
)

# Return results as a Python dict
py_comprehension(
  i ~ reticulate::r_to_py(1:3),
  list(i, i^2),
  format = py_builtins$dict()
)
}

}
