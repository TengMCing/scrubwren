% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/py_for.R
\name{py_comprehension}
\alias{py_comprehension}
\title{Python-Style Comprehension in R}
\usage{
py_comprehension(
  loop_spec_list,
  body,
  env = parent.frame(),
  format = py_builtins$list()
)
}
\arguments{
\item{loop_spec_list}{Formula/List. A single formula or a vector of formulas specifying the loops.
Each formula must be of the form \code{var ~ iterable} or \code{var ~ iterable | condition}, where \code{var} is
the loop variable and \code{iterable} is a Python iterable object.}

\item{body}{Expression. An R expression to evaluate inside the innermost loop.
Its result is collected into the comprehension output.}

\item{env}{Environment. The parent environment for evaluation; defaults to
the caller's environment. The comprehension is evaluated
in a \strong{new environment} created on top of this provided \code{env}, so that
variables created or modified inside \code{body} do not affect the outer
environment unless global modification is explicitly used.}

\item{format}{A Python collection type or a regular R list to store the results.
Defaults to a Python list (\code{py_builtins$list()}).}
}
\value{
A Python collection or R list containing the results of the comprehension.
}
\description{
Evaluate Python-like comprehensions in R. Supports multiple nested loops
with optional conditions and returns results in a specified Python
collection type (\code{list}, \code{tuple}, \code{set}, or \code{dict}),
or as a regular R list.
}
\details{
When \code{format = py_builtins$dict()}, each evaluation of \code{body} must
return a \strong{key-value pair}. Valid pair formats include:
\itemize{
\item A Python tuple of length 2
\item A Python list of length 2
\item A regular R list of length 2
}

The first element is used as the key and the second as the value.
This allows creating dictionaries in Python style directly from R comprehensions.
}
\examples{
\dontrun{
# Simple Python-style comprehension (squares)
py_comprehension(
  i ~ reticulate::r_to_py(1:3),
  i^2
)
# Returns a Python list: [1, 4, 9]

# Nested loops with conditions using Python lists
test <- reticulate::r_to_py(list(list(1, 2, 3), list(1, 2), list(1)))
py_comprehension(
  c(
    x ~ test | py_builtins$len(x) > 1,
    z ~ x | z > 1
  ),
  {
    a <- z + 1
    a
  }
)

# Return results as a regular R list
py_comprehension(
  i ~ reticulate::r_to_py(1:3),
  i^2,
  format = list()
)

# Return results as a Python tuple
py_comprehension(
  i ~ reticulate::r_to_py(1:3),
  i^2,
  format = py_builtins$tuple()
)

# Return results as a Python set
py_comprehension(
  i ~ reticulate::r_to_py(c(1, 2, 2, 3)),
  i^2,
  format = py_builtins$set()
)
# Returns a Python set: {1, 4, 9}

# Return results as a Python dict
py_comprehension(
  i ~ reticulate::r_to_py(1:3),
  list(i, i^2),
  format = py_builtins$dict()
)
}

}
