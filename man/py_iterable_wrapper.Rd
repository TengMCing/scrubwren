% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/py_iter_wrapper.R
\name{py_iterable_wrapper}
\alias{py_iterable_wrapper}
\title{Wrap a Python iterable with a custom function}
\usage{
py_iterable_wrapper(obj, func, convert = FALSE)
}
\arguments{
\item{obj}{A Python iterable or iterator object. If it is
iterable but not an iterator, it will be converted to an iterator internally.}

\item{func}{An R or Python function to apply to each element of the iterable.}

\item{convert}{Boolean. Whether to automatically convert each value to R object.}
}
\value{
A Python iterator object whose elements are transformed by \code{func}. Each
call to \code{next()} returns \code{func(element)}.
}
\description{
This function wraps a Python iterable or iterator so that each
element is transformed by a specified function when iterated over. The returned
object behaves like a Python iterator, applying the transformation lazily on each element.
}
\details{
\itemize{
\item If \code{obj} is iterable but not already an iterator, it is converted to a Python iterator
using \code{reticulate::as_iterator()}.
\item The returned object implements the Python iterator protocol (\verb{__iter__} and \verb{__len__}).
\item The function \code{func} is applied lazily: the transformation occurs only when elements are
retrieved from the iterator.
}
}
\examples{
\dontrun{
my_list <- py_builtins$list(1:5)
wrapped_iter <- py_iterable_wrapper(my_list, function(x) x^2) |>
  reticulate::as_iterator()
reticulate::iter_next(wrapped_iter)  # Returns 1
reticulate::iter_next(wrapped_iter)  # Returns 4
}

}
