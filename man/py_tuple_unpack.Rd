% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/py_tuple_unpack.R
\name{py_tuple_unpack}
\alias{py_tuple_unpack}
\title{Unpack a Python tuple (or sequence) into R variables}
\usage{
py_tuple_unpack(vars, value, envir = parent.frame(), quote_vars = TRUE)
}
\arguments{
\item{vars}{A symbol or a call like \code{c(a, b, c)} representing the
variables to assign into.}

\item{value}{A Python object (tuple, list, etc.) or an R vector/list to
unpack.}

\item{envir}{Environment. Environment in which to assign the unpacked values.
Defaults to the calling environment.}

\item{quote_vars}{Boolean. If \code{TRUE}, \code{vars} is captured unevaluated
(recommended when writing \code{c(a, b, c)} directly).}
}
\value{
Invisibly returns \code{NULL}. Called for side effects.
}
\description{
This function unpacks elements of a Python tuple (or any sequence-like
object) into R variables, similar to tuple unpacking in Python
(\verb{a, b = (1, 2)}).
}
\details{
If \code{vars} is a vector of names created with \code{c(...)}, each element of
\code{value} is assigned to the corresponding variable in the calling
environment. Nested unpacking is supported recursively.

If the number of elements in \code{value} exceeds the number of variables
provided, a warning is issued but unpacking proceeds for the available
variables.
}
\examples{
\dontrun{
# Simple unpacking
py_tuple_unpack(c(a, b), list(1, 2))
a  # 1
b  # 2

# With nested unpacking
py_tuple_unpack(c(a, c(b, d)), list(1, list(2, 3)))
a  # 1
b  # 2
d  # 3

# Works with Python tuples/lists
tup <- reticulate::tuple(list(10, list(20, 30)))
py_tuple_unpack(c(x, c(y, z)), tup)
x  # 10
y  # 20
z  # 30
}

}
