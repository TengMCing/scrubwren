% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/py_for.R
\name{py_iterable_check}
\alias{py_iterable_check}
\alias{py_is_iterable}
\alias{py_is_iterator}
\title{Test whether a Python object is iterable or an iterator}
\usage{
py_is_iterable(obj)

py_is_iterator(obj)
}
\arguments{
\item{obj}{A Python object proxy.}
}
\value{
A Boolean scalar (\code{TRUE} or \code{FALSE}).
}
\description{
These functions check the iteration protocol of a Python object
when accessed from R through \code{reticulate}.
}
\details{
\itemize{
\item \code{py_is_iterable()} returns \code{TRUE} if the object can return an iterator
via Python's \code{iter()} function, otherwise \code{FALSE}.
\item \code{py_is_iterator()} returns \code{TRUE} if the object itself is an iterator,
i.e. an instance of \code{collections.abc.Iterator}.
}
}
\examples{
\dontrun{
np <- reticulate::import("numpy", convert = FALSE)

# A Python list is iterable but not an iterator
lst <- reticulate::r_to_py(list(1, 2, 3))
py_is_iterable(lst)   # TRUE
py_is_iterator(lst)   # FALSE

# An iterator (e.g., from iter()) is both iterable and an iterator
it <- py_builtins$iter(lst)
py_is_iterable(it)    # TRUE
py_is_iterator(it)    # TRUE
}

}
\seealso{
Python's \href{https://docs.python.org/3/library/stdtypes.html#typeiter}{iterator protocol}
}
