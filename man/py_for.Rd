% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/py_for.R
\name{py_for}
\alias{py_for}
\title{Python-style \code{for} loops in R}
\usage{
py_for(loop_spec, body, env = parent.frame())
}
\arguments{
\item{loop_spec}{A two-sided formula of the form \code{vars ~ iterable}, where
\code{vars} specifies one or more loop variables (e.g. \code{x} or \code{c(i, j)}), and
\code{iterable} is a Python iterable or iterator.}

\item{body}{An R expression to evaluate on each iteration.}

\item{env}{The environment in which to run the loop and evaluate the body.
Defaults to the calling environment.}
}
\value{
Invisibly returns \code{NULL}. Called for side effects.
}
\description{
Executes a Python-style \code{for} loop in R, iterating over a Python iterable or
iterator. This provides a convenient syntax for looping with destructuring
(tuple unpacking) similar to Python's \code{for} statement.
}
\details{
\itemize{
\item If \code{iterable} implements only \verb{__iter__} but not \verb{__next__}, it is
automatically converted into an iterator.
\item Loop variables support tuple unpacking via \code{\link[=py_tuple_unpack]{py_tuple_unpack()}}.
\item The loop tracks whether the user calls \code{break} or \code{next} inside the loop:
\itemize{
\item \code{break} exits the loop early, skipping any remaining iterations.
\item \code{next} skips to the next iteration without stopping the loop entirely.
\item If neither is called, the loop proceeds normally.
}
}
}
\examples{
\dontrun{

# Basic loop over a Python list with loop control
py_for(x ~ reticulate::r_to_py(list(1, 2, 3)), {
  if (reticulate::py_to_r(x) == 2) next  # skip printing 2
  if (reticulate::py_to_r(x) == 3) break # exit before printing 3
  print(x)
})

# Loop over a Python list
py_for(x ~ reticulate::r_to_py(list(1, 2, 3)), {
  print(x)
})

# Loop with tuple unpacking
pairs <- reticulate::tuple(list(list(1, "a"), list(2, "b")), convert = TRUE)
py_for(c(i, j) ~ pairs, {
  cat("i =", i, " j =", j, "\n")
})

# Loop over a NumPy array
np <- reticulate::import("numpy", convert = FALSE)
arr <- np$array(c(10, 20, 30))
py_for(val ~ arr, {
  print(val)
})
}

}
